!function(){"use strict";function a(a,b,c){try{return window.URL.createObjectURL(new Blob([Uint8Array.from(a.split("").map(function(a){return a.charCodeAt(0)}))],{type:b}))}catch(d){return"data:"+b+(c?";base64,":",")+a}}function g(a){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(a)?a:new Uint8Array(a||0),this.pos=0,this.type=0,this.length=this.buf.length}function j(a,b,c){var e,f,d=c.buf;if(f=d[c.pos++],e=(112&f)>>4,f<128)return l(a,e,b);if(f=d[c.pos++],e|=(127&f)<<3,f<128)return l(a,e,b);if(f=d[c.pos++],e|=(127&f)<<10,f<128)return l(a,e,b);if(f=d[c.pos++],e|=(127&f)<<17,f<128)return l(a,e,b);if(f=d[c.pos++],e|=(127&f)<<24,f<128)return l(a,e,b);if(f=d[c.pos++],e|=(1&f)<<31,f<128)return l(a,e,b);throw new Error("Expected varint not more than 10 bytes")}function k(a){return a.type===g.Bytes?a.readVarint()+a.pos:a.pos+1}function l(a,b,c){return c?4294967296*b+(a>>>0):4294967296*(b>>>0)+(a>>>0)}function m(a,b){var c,d;if(a>=0?(c=a%4294967296|0,d=a/4294967296|0):(c=~(-a%4294967296),d=~(-a/4294967296),4294967295^c?c=c+1|0:(c=0,d=d+1|0)),a>=0x10000000000000000||a<-0x10000000000000000)throw new Error("Given varint doesn't fit into 10 bytes");b.realloc(10),n(c,d,b),o(d,b)}function n(a,b,c){c.buf[c.pos++]=127&a|128,a>>>=7,c.buf[c.pos++]=127&a|128,a>>>=7,c.buf[c.pos++]=127&a|128,a>>>=7,c.buf[c.pos++]=127&a|128,a>>>=7,c.buf[c.pos]=127&a}function o(a,b){var c=(7&a)<<4;b.buf[b.pos++]|=c|((a>>>=3)?128:0),a&&(b.buf[b.pos++]=127&a|((a>>>=7)?128:0),a&&(b.buf[b.pos++]=127&a|((a>>>=7)?128:0),a&&(b.buf[b.pos++]=127&a|((a>>>=7)?128:0),a&&(b.buf[b.pos++]=127&a|((a>>>=7)?128:0),a&&(b.buf[b.pos++]=127&a)))))}function p(a,b,c){var d=b<=16383?1:b<=2097151?2:b<=268435455?3:Math.ceil(Math.log(b)/(7*Math.LN2));c.realloc(d);for(var e=c.pos-1;e>=a;e--)c.buf[e+d]=c.buf[e]}function q(a,b){for(var c=0;c<a.length;c++)b.writeVarint(a[c])}function r(a,b){for(var c=0;c<a.length;c++)b.writeSVarint(a[c])}function s(a,b){for(var c=0;c<a.length;c++)b.writeFloat(a[c])}function t(a,b){for(var c=0;c<a.length;c++)b.writeDouble(a[c])}function u(a,b){for(var c=0;c<a.length;c++)b.writeBoolean(a[c])}function v(a,b){for(var c=0;c<a.length;c++)b.writeFixed32(a[c])}function w(a,b){for(var c=0;c<a.length;c++)b.writeSFixed32(a[c])}function x(a,b){for(var c=0;c<a.length;c++)b.writeFixed64(a[c])}function y(a,b){for(var c=0;c<a.length;c++)b.writeSFixed64(a[c])}function z(a,b){return(a[b]|a[b+1]<<8|a[b+2]<<16)+16777216*a[b+3]}function A(a,b,c){a[c]=b,a[c+1]=b>>>8,a[c+2]=b>>>16,a[c+3]=b>>>24}function B(a,b){return(a[b]|a[b+1]<<8|a[b+2]<<16)+(a[b+3]<<24)}function C(a,b,c){for(var d="",e=b;e<c;){var f=a[e],g=null,h=f>239?4:f>223?3:f>191?2:1;if(e+h>c)break;var i,j,k;1===h?f<128&&(g=f):2===h?128==(192&(i=a[e+1]))&&(g=(31&f)<<6|63&i)<=127&&(g=null):3===h?(i=a[e+1],j=a[e+2],128==(192&i)&&128==(192&j)&&((g=(15&f)<<12|(63&i)<<6|63&j)<=2047||g>=55296&&g<=57343)&&(g=null)):4===h&&(i=a[e+1],j=a[e+2],k=a[e+3],128==(192&i)&&128==(192&j)&&128==(192&k)&&((g=(15&f)<<18|(63&i)<<12|(63&j)<<6|63&k)<=65535||g>=1114112)&&(g=null)),null===g?(g=65533,h=1):g>65535&&(g-=65536,d+=String.fromCharCode(g>>>10&1023|55296),g=56320|1023&g),d+=String.fromCharCode(g),e+=h}return d}function D(a,b,c){for(var e,f,d=0;d<b.length;d++){if((e=b.charCodeAt(d))>55295&&e<57344){if(!f){e>56319||d+1===b.length?(a[c++]=239,a[c++]=191,a[c++]=189):f=e;continue}if(e<56320){a[c++]=239,a[c++]=191,a[c++]=189,f=e;continue}e=f-55296<<10|e-56320|65536,f=null}else f&&(a[c++]=239,a[c++]=191,a[c++]=189,f=null);e<128?a[c++]=e:(e<2048?a[c++]=e>>6|192:(e<65536?a[c++]=e>>12|224:(a[c++]=e>>18|240,a[c++]=e>>12&63|128),a[c++]=e>>6&63|128),a[c++]=63&e|128)}return c}function F(a,b){this.x=a,this.y=b}function I(a,b,c,d,e){this.properties={},this.extent=c,this.type=0,this._pbf=a,this._geometry=-1,this._keys=d,this._values=e,a.readFields(J,this,b)}function J(a,b,c){1==a?b.id=c.readVarint():2==a?K(c,b):3==a?b.type=c.readVarint():4==a&&(b._geometry=c.pos)}function K(a,b){for(var c=a.readVarint()+a.pos;a.pos<c;){var d=b._keys[a.readVarint()],e=b._values[a.readVarint()];b.properties[d]=e}}function M(a){var b=a.length;if(b<=1)return[a];for(var d,e,c=[],f=0;f<b;f++){var g=N(a[f]);0!==g&&(void 0===e&&(e=g<0),e===g<0?(d&&c.push(d),d=[a[f]]):d.push(a[f]))}return d&&c.push(d),c}function N(a){for(var f,g,b=0,c=0,d=a.length,e=d-1;c<d;e=c++)f=a[c],g=a[e],b+=(g.x-f.x)*(f.y+g.y);return b}function Q(a,b){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=a,this._keys=[],this._values=[],this._features=[],a.readFields(R,this,b),this.length=this._features.length}function R(a,b,c){15===a?b.version=c.readVarint():1===a?b.name=c.readString():5===a?b.extent=c.readVarint():2===a?b._features.push(c.pos):3===a?b._keys.push(c.readString()):4===a&&b._values.push(S(c))}function S(a){for(var b=null,c=a.readVarint()+a.pos;a.pos<c;){var d=a.readVarint()>>3;b=1===d?a.readString():2===d?a.readFloat():3===d?a.readDouble():4===d?a.readVarint64():5===d?a.readVarint():6===d?a.readSVarint():7===d?a.readBoolean():null}return b}function V(a,b){this.layers=a.readFields(W,{},b)}function W(a,b,c){if(3===a){var d=new T(c,c.readVarint()+c.pos);d.length&&(b[d.name]=d)}}var b=function(a,b,c,d,e){var f,g,h=8*e-d-1,i=(1<<h)-1,j=i>>1,k=-7,l=c?e-1:0,m=c?-1:1,n=a[b+l];for(l+=m,f=n&(1<<-k)-1,n>>=-k,k+=h;k>0;f=256*f+a[b+l],l+=m,k-=8);for(g=f&(1<<-k)-1,f>>=-k,k+=d;k>0;g=256*g+a[b+l],l+=m,k-=8);if(0===f)f=1-j;else{if(f===i)return g?NaN:1/0*(n?-1:1);g+=Math.pow(2,d),f-=j}return(n?-1:1)*g*Math.pow(2,f-d)},c=function(a,b,c,d,e,f){var g,h,i,j=8*f-e-1,k=(1<<j)-1,l=k>>1,m=23===e?Math.pow(2,-24)-Math.pow(2,-77):0,n=d?0:f-1,o=d?1:-1,p=b<0||0===b&&1/b<0?1:0;for(b=Math.abs(b),isNaN(b)||b===1/0?(h=isNaN(b)?1:0,g=k):(g=Math.floor(Math.log(b)/Math.LN2),b*(i=Math.pow(2,-g))<1&&(g--,i*=2),b+=g+l>=1?m/i:m*Math.pow(2,1-l),b*i>=2&&(g++,i/=2),g+l>=k?(h=0,g=k):g+l>=1?(h=(b*i-1)*Math.pow(2,e),g+=l):(h=b*Math.pow(2,l-1)*Math.pow(2,e),g=0));e>=8;a[c+n]=255&h,n+=o,h/=256,e-=8);for(g=g<<e|h,j+=e;j>0;a[c+n]=255&g,n+=o,g/=256,j-=8);a[c+n-o]|=128*p},d={read:b,write:c},e=g,f=d;g.Varint=0,g.Fixed64=1,g.Bytes=2,g.Fixed32=5;var h=4294967296,i=1/h;g.prototype={destroy:function(){this.buf=null},readFields:function(a,b,c){var d=this;for(c=c||this.length;this.pos<c;){var e=d.readVarint(),f=e>>3,g=d.pos;d.type=7&e,a(f,b,d),d.pos===g&&d.skip(e)}return b},readMessage:function(a,b){return this.readFields(a,b,this.readVarint()+this.pos)},readFixed32:function(){var a=z(this.buf,this.pos);return this.pos+=4,a},readSFixed32:function(){var a=B(this.buf,this.pos);return this.pos+=4,a},readFixed64:function(){var a=z(this.buf,this.pos)+z(this.buf,this.pos+4)*h;return this.pos+=8,a},readSFixed64:function(){var a=z(this.buf,this.pos)+B(this.buf,this.pos+4)*h;return this.pos+=8,a},readFloat:function(){var a=f.read(this.buf,this.pos,!0,23,4);return this.pos+=4,a},readDouble:function(){var a=f.read(this.buf,this.pos,!0,52,8);return this.pos+=8,a},readVarint:function(a){var c,d,b=this.buf;return d=b[this.pos++],c=127&d,d<128?c:(d=b[this.pos++],c|=(127&d)<<7,d<128?c:(d=b[this.pos++],c|=(127&d)<<14,d<128?c:(d=b[this.pos++],c|=(127&d)<<21,d<128?c:(d=b[this.pos],c|=(15&d)<<28,j(c,a,this)))))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var a=this.readVarint();return a%2==1?(a+1)/-2:a/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var a=this.readVarint()+this.pos,b=C(this.buf,this.pos,a);return this.pos=a,b},readBytes:function(){var a=this.readVarint()+this.pos,b=this.buf.subarray(this.pos,a);return this.pos=a,b},readPackedVarint:function(a,b){var c=this,d=k(this);for(a=a||[];this.pos<d;)a.push(c.readVarint(b));return a},readPackedSVarint:function(a){var b=this,c=k(this);for(a=a||[];this.pos<c;)a.push(b.readSVarint());return a},readPackedBoolean:function(a){var b=this,c=k(this);for(a=a||[];this.pos<c;)a.push(b.readBoolean());return a},readPackedFloat:function(a){var b=this,c=k(this);for(a=a||[];this.pos<c;)a.push(b.readFloat());return a},readPackedDouble:function(a){var b=this,c=k(this);for(a=a||[];this.pos<c;)a.push(b.readDouble());return a},readPackedFixed32:function(a){var b=this,c=k(this);for(a=a||[];this.pos<c;)a.push(b.readFixed32());return a},readPackedSFixed32:function(a){var b=this,c=k(this);for(a=a||[];this.pos<c;)a.push(b.readSFixed32());return a},readPackedFixed64:function(a){var b=this,c=k(this);for(a=a||[];this.pos<c;)a.push(b.readFixed64());return a},readPackedSFixed64:function(a){var b=this,c=k(this);for(a=a||[];this.pos<c;)a.push(b.readSFixed64());return a},skip:function(a){var b=7&a;if(b===g.Varint)for(;this.buf[this.pos++]>127;);else if(b===g.Bytes)this.pos=this.readVarint()+this.pos;else if(b===g.Fixed32)this.pos+=4;else{if(b!==g.Fixed64)throw new Error("Unimplemented type: "+b);this.pos+=8}},writeTag:function(a,b){this.writeVarint(a<<3|b)},realloc:function(a){for(var b=this.length||16;b<this.pos+a;)b*=2;if(b!==this.length){var c=new Uint8Array(b);c.set(this.buf),this.buf=c,this.length=b}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(a){this.realloc(4),A(this.buf,a,this.pos),this.pos+=4},writeSFixed32:function(a){this.realloc(4),A(this.buf,a,this.pos),this.pos+=4},writeFixed64:function(a){this.realloc(8),A(this.buf,-1&a,this.pos),A(this.buf,Math.floor(a*i),this.pos+4),this.pos+=8},writeSFixed64:function(a){this.realloc(8),A(this.buf,-1&a,this.pos),A(this.buf,Math.floor(a*i),this.pos+4),this.pos+=8},writeVarint:function(a){if((a=+a||0)>268435455||a<0)return void m(a,this);this.realloc(4),this.buf[this.pos++]=127&a|(a>127?128:0),a<=127||(this.buf[this.pos++]=127&(a>>>=7)|(a>127?128:0),a<=127||(this.buf[this.pos++]=127&(a>>>=7)|(a>127?128:0),a<=127||(this.buf[this.pos++]=a>>>7&127)))},writeSVarint:function(a){this.writeVarint(a<0?2*-a-1:2*a)},writeBoolean:function(a){this.writeVarint(Boolean(a))},writeString:function(a){a=String(a),this.realloc(4*a.length),this.pos++;var b=this.pos;this.pos=D(this.buf,a,this.pos);var c=this.pos-b;c>=128&&p(b,c,this),this.pos=b-1,this.writeVarint(c),this.pos+=c},writeFloat:function(a){this.realloc(4),f.write(this.buf,a,this.pos,!0,23,4),this.pos+=4},writeDouble:function(a){this.realloc(8),f.write(this.buf,a,this.pos,!0,52,8),this.pos+=8},writeBytes:function(a){var b=this,c=a.length;this.writeVarint(c),this.realloc(c);for(var d=0;d<c;d++)b.buf[b.pos++]=a[d]},writeRawMessage:function(a,b){this.pos++;var c=this.pos;a(b,this);var d=this.pos-c;d>=128&&p(c,d,this),this.pos=c-1,this.writeVarint(d),this.pos+=d},writeMessage:function(a,b,c){this.writeTag(a,g.Bytes),this.writeRawMessage(b,c)},writePackedVarint:function(a,b){this.writeMessage(a,q,b)},writePackedSVarint:function(a,b){this.writeMessage(a,r,b)},writePackedBoolean:function(a,b){this.writeMessage(a,u,b)},writePackedFloat:function(a,b){this.writeMessage(a,s,b)},writePackedDouble:function(a,b){this.writeMessage(a,t,b)},writePackedFixed32:function(a,b){this.writeMessage(a,v,b)},writePackedSFixed32:function(a,b){this.writeMessage(a,w,b)},writePackedFixed64:function(a,b){this.writeMessage(a,x,b)},writePackedSFixed64:function(a,b){this.writeMessage(a,y,b)},writeBytesField:function(a,b){this.writeTag(a,g.Bytes),this.writeBytes(b)},writeFixed32Field:function(a,b){this.writeTag(a,g.Fixed32),this.writeFixed32(b)},writeSFixed32Field:function(a,b){this.writeTag(a,g.Fixed32),this.writeSFixed32(b)},writeFixed64Field:function(a,b){this.writeTag(a,g.Fixed64),this.writeFixed64(b)},writeSFixed64Field:function(a,b){this.writeTag(a,g.Fixed64),this.writeSFixed64(b)},writeVarintField:function(a,b){this.writeTag(a,g.Varint),this.writeVarint(b)},writeSVarintField:function(a,b){this.writeTag(a,g.Varint),this.writeSVarint(b)},writeStringField:function(a,b){this.writeTag(a,g.Bytes),this.writeString(b)},writeFloatField:function(a,b){this.writeTag(a,g.Fixed32),this.writeFloat(b)},writeDoubleField:function(a,b){this.writeTag(a,g.Fixed64),this.writeDouble(b)},writeBooleanField:function(a,b){this.writeVarintField(a,Boolean(b))}};var E=F;F.prototype={clone:function(){return new F(this.x,this.y)},add:function(a){return this.clone()._add(a)},sub:function(a){return this.clone()._sub(a)},mult:function(a){return this.clone()._mult(a)},div:function(a){return this.clone()._div(a)},rotate:function(a){return this.clone()._rotate(a)},matMult:function(a){return this.clone()._matMult(a)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(a){return this.x===a.x&&this.y===a.y},dist:function(a){return Math.sqrt(this.distSqr(a))},distSqr:function(a){var b=a.x-this.x,c=a.y-this.y;return b*b+c*c},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(a){return Math.atan2(this.y-a.y,this.x-a.x)},angleWith:function(a){return this.angleWithSep(a.x,a.y)},angleWithSep:function(a,b){return Math.atan2(this.x*b-this.y*a,this.x*a+this.y*b)},_matMult:function(a){var b=a[0]*this.x+a[1]*this.y,c=a[2]*this.x+a[3]*this.y;return this.x=b,this.y=c,this},_add:function(a){return this.x+=a.x,this.y+=a.y,this},_sub:function(a){return this.x-=a.x,this.y-=a.y,this},_mult:function(a){return this.x*=a,this.y*=a,this},_div:function(a){return this.x/=a,this.y/=a,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var a=this.y;return this.y=this.x,this.x=-a,this},_rotate:function(a){var b=Math.cos(a),c=Math.sin(a),d=b*this.x-c*this.y,e=c*this.x+b*this.y;return this.x=d,this.y=e,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},F.convert=function(a){return a instanceof F?a:Array.isArray(a)?new F(a[0],a[1]):a};var G=E,H=I;I.types=["Unknown","Point","LineString","Polygon"],I.prototype.loadGeometry=function(){var a=this._pbf;a.pos=this._geometry;for(var h,b=a.readVarint()+a.pos,c=1,d=0,e=0,f=0,g=[];a.pos<b;){if(!d){var i=a.readVarint();c=7&i,d=i>>3}if(d--,1===c||2===c)e+=a.readSVarint(),f+=a.readSVarint(),1===c&&(h&&g.push(h),h=[]),h.push(new G(e,f));else{if(7!==c)throw new Error("unknown command "+c);h&&h.push(h[0].clone())}}return h&&g.push(h),g},I.prototype.bbox=function(){var a=this._pbf;a.pos=this._geometry;for(var b=a.readVarint()+a.pos,c=1,d=0,e=0,f=0,g=1/0,h=-1/0,i=1/0,j=-1/0;a.pos<b;){if(!d){var k=a.readVarint();c=7&k,d=k>>3}if(d--,1===c||2===c)e+=a.readSVarint(),f+=a.readSVarint(),e<g&&(g=e),e>h&&(h=e),f<i&&(i=f),f>j&&(j=f);else if(7!==c)throw new Error("unknown command "+c)}return[g,i,h,j]},I.prototype.toGeoJSON=function(a,b,c){function k(a){for(var b=0;b<a.length;b++){var c=a[b],g=180-360*(c.y+f)/d;a[b]=[360*(c.x+e)/d-180,360/Math.PI*Math.atan(Math.exp(g*Math.PI/180))-90]}}var i,j,d=this.extent*Math.pow(2,c),e=this.extent*a,f=this.extent*b,g=this.loadGeometry(),h=I.types[this.type];switch(this.type){case 1:var l=[];for(i=0;i<g.length;i++)l[i]=g[i][0];g=l,k(g);break;case 2:for(i=0;i<g.length;i++)k(g[i]);break;case 3:for(g=M(g),i=0;i<g.length;i++)for(j=0;j<g[i].length;j++)k(g[i][j])}1===g.length?g=g[0]:h="Multi"+h;var m={type:"Feature",geometry:{type:h,coordinates:g},properties:this.properties};return"id"in this&&(m.id=this.id),m};var O=H,P=Q;Q.prototype.feature=function(a){if(a<0||a>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[a];var b=this._pbf.readVarint()+this._pbf.pos;return new O(this._pbf,b,this.extent,this._keys,this._values)};var T=P,U=V,X=U;L.SVG.Tile=L.SVG.extend({initialize:function(a,b,c){L.SVG.prototype.initialize.call(this,c),this._tileCoord=a,this._size=b,this._initContainer(),this._container.setAttribute("width",this._size.x),this._container.setAttribute("height",this._size.y),this._container.setAttribute("viewBox",[0,0,this._size.x,this._size.y].join(" ")),c.interactive&&(this._container.style.pointerEvents="auto"),this._layers={}},getCoord:function(){return this._tileCoord},getContainer:function(){return this._container},onAdd:L.Util.falseFn,addTo:function(a){if(this._map=a,this.options.interactive)for(var b in this._layers){var c=this._layers[b];this._map._targets[L.stamp(c._path)]=c}},_initContainer:function(){L.SVG.prototype._initContainer.call(this);L.SVG.create("rect")},_addPath:function(a){this._rootGroup.appendChild(a._path),this._layers[L.stamp(a)]=a}}),L.svg.tile=function(a,b,c){return new L.SVG.Tile(a,b,c)},L.VectorGrid=L.GridLayer.extend({options:{rendererFactory:L.svg.tile,vectorTileLayerStyles:{},interactive:!1},initialize:function(a){L.setOptions(this,a),L.GridLayer.prototype.initialize.apply(this,arguments),this.options.getFeatureId&&(this._vectorTiles={},this._overriddenStyles={},this.on("tileunload",function(a){delete this._vectorTiles[this._tileCoordsToKey(a.coords)]},this))},createTile:function(a,b){var c=this.options.getFeatureId,d=this.getTileSize(),e=this.options.rendererFactory(a,d,this.options),f=this._getVectorTilePromise(a);return c&&(this._vectorTiles[this._tileCoordsToKey(a)]=e,e._features={}),f.then(function(f){for(var g in f.layers){var h=f.layers[g],i=this.getTileSize().x/h.extent,j=this.options.vectorTileLayerStyles[g]||L.Path.prototype.options;for(var k in h.features){var m,l=h.features[k],n=j;if(c){m=this.options.getFeatureId(l);var o=this._overriddenStyles[m];o&&(n=o[g]?o[g]:o)}if(n instanceof Function&&(n=n(l.properties,a.z)),n instanceof Array||(n=[n]),n.length){var p=this._createLayer(l,i);for(var q in n){var r=L.extend({},L.Path.prototype.options,n[q]);p.render(e,r),e._addPath(p)}this.options.interactive&&p.makeInteractive(),c&&(e._features[m]={layerName:g,feature:p})}}}e.addTo(this._map),L.Util.requestAnimFrame(b.bind(a,null,null))}.bind(this)),e.getContainer()},setFeatureStyle:function(a,b){this._overriddenStyles[a]={};for(var c in this._vectorTiles){var d=this._vectorTiles[c],e=d._features,f=e[a];if(f){this._overriddenStyles[a]=b;var g=f.feature,h=b;b[f.layerName]&&(h=b[f.layerName]),h=h instanceof Function?h(g.properties,d.getCoord().z):h,this._updateStyles(g,d,h)}else this._overriddenStyles[a]=b}},resetFeatureStyle:function(a){delete this._overriddenStyles[a];for(var b in this._vectorTiles){var c=this._vectorTiles[b],d=c._features,e=d[a];if(e){var f=e.feature,g=this.options.vectorTileLayerStyles[e.layerName]||L.Path.prototype.options,h=g instanceof Function?g(f.properties,c.getCoord().z):g;this._updateStyles(f,c,h)}}},_updateStyles:function(a,b,c){c instanceof Array||(c=[c]);for(var d in c){var e=L.extend({},L.Path.prototype.options,c[d]);a.updateStyle(b,e)}},_createLayer:function(a,b,c){var d;switch(a.type){case 1:d=new Z(a,b,this.options.interactive);break;case 2:d=new _(a,b,this.options.interactive);break;case 3:d=new aa(a,b,this.options.interactive)}return this.options.interactive&&d.addEventParent(this),d}}),L.vectorGrid=function(a){return new L.VectorGrid(a)};var Y=L.Class.extend({render:function(a,b){this._renderer=a,this.options=b,a._initPath(this),a._updateStyle(this)},updateStyle:function(a,b){this.options=b,a._updateStyle(this)},_getPixelBounds:function(){for(var a=this._parts,b=L.bounds([]),c=0;c<a.length;c++)for(var d=a[c],e=0;e<d.length;e++)b.extend(d[e]);var f=this._clickTolerance(),g=new L.Point(f,f);return b.min._subtract(g),b.max._add(g),b},_clickTolerance:L.Path.prototype._clickTolerance}),Z=L.CircleMarker.extend({includes:Y.prototype,initialize:function(a,b){this.properties=a.properties,this._makeFeatureParts(a,b)},render:function(a,b){Y.prototype.render.call(this,a,b),this._radius=b.radius,this._updatePath()},_makeFeatureParts:function(a,b){var c=a.geometry[0][0];"x"in c&&(this._point=L.point(c.x*b,c.y*b),this._empty=L.Util.falseFn)},makeInteractive:function(){var a=this._radius,b=this._radiusY||a,c=this._clickTolerance(),d=[a+c,b+c];this._pxBounds=new L.Bounds(this._point.subtract(d),this._point.add(d))}}),$={_makeFeatureParts:function(a,b){var d,c=a.geometry;this._parts=[];for(var e in c){var f=c[e],g=[];for(var h in f)d=f[h],"x"in d?g.push(L.point(d.x*b,d.y*b)):g.push(L.point(d[0]*b,d[1]*b));this._parts.push(g)}},makeInteractive:function(){this._pxBounds=this._getPixelBounds()}},_=L.Polyline.extend({includes:[Y.prototype,$],initialize:function(a,b){this.properties=a.properties,this._makeFeatureParts(a,b)},render:function(a,b){b.fill=!1,Y.prototype.render.call(this,a,b),this._updatePath()},updateStyle:function(a,b){b.fill=!1,Y.prototype.updateStyle.call(this,a,b)}}),aa=L.Polygon.extend({includes:[Y.prototype,$],initialize:function(a,b){this.properties=a.properties,this._makeFeatureParts(a,b)},render:function(a,b){Y.prototype.render.call(this,a,b),this._updatePath()}});L.VectorGrid.Protobuf=L.VectorGrid.extend({options:{subdomains:"abc"},initialize:function(a,b){this._url=a,L.VectorGrid.prototype.initialize.call(this,b)},_getSubdomain:L.TileLayer.prototype._getSubdomain,_getVectorTilePromise:function(a){var b=L.Util.template(this._url,L.extend({s:this._getSubdomain(a),x:a.x,y:a.y,z:a.z},this.options));return fetch(b).then(function(a){return a.ok?a.blob().then(function(a){var b=new FileReader;return new Promise(function(c){b.addEventListener("loadend",function(){var a=new e(b.result);return c(new X(a))}),b.readAsArrayBuffer(a)})}):{layers:[]}}).then(function(a){for(var b in a.layers){for(var c=[],d=0;d<a.layers[b].length;d++){var e=a.layers[b].feature(d);e.geometry=e.loadGeometry(),c.push(e)}a.layers[b].features=c}return a})}}),L.vectorGrid.protobuf=function(a,b){return new L.VectorGrid.Protobuf(a,b)};var ba=a("'use strict';\n\nvar simplify_1 = simplify$1;\n\n// calculate simplification data using optimized Douglas-Peucker algorithm\n\nfunction simplify$1(points, tolerance) {\n\n    var sqTolerance = tolerance * tolerance,\n        len = points.length,\n        first = 0,\n        last = len - 1,\n        stack = [],\n        i, maxSqDist, sqDist, index;\n\n    // always retain the endpoints (1 is the max value)\n    points[first][2] = 1;\n    points[last][2] = 1;\n\n    // avoid recursion by using a stack\n    while (last) {\n\n        maxSqDist = 0;\n\n        for (i = first + 1; i < last; i++) {\n            sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n            if (sqDist > maxSqDist) {\n                index = i;\n                maxSqDist = sqDist;\n            }\n        }\n\n        if (maxSqDist > sqTolerance) {\n            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate\n            stack.push(first);\n            stack.push(index);\n            first = index;\n\n        } else {\n            last = stack.pop();\n            first = stack.pop();\n        }\n    }\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, a, b) {\n\n    var x = a[0], y = a[1],\n        bx = b[0], by = b[1],\n        px = p[0], py = p[1],\n        dx = bx - x,\n        dy = by - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = bx;\n            y = by;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n\nvar feature = createFeature$1;\n\nfunction createFeature$1(tags, type, geom, id) {\n    var feature = {\n        id: id || null,\n        type: type,\n        geometry: geom,\n        tags: tags || null,\n        min: [Infinity, Infinity], // initial bbox values\n        max: [-Infinity, -Infinity]\n    };\n    calcBBox(feature);\n    return feature;\n}\n\n// calculate the feature bounding box for faster clipping later\nfunction calcBBox(feature) {\n    var geometry = feature.geometry,\n        min = feature.min,\n        max = feature.max;\n\n    if (feature.type === 1) {\n        calcRingBBox(min, max, geometry);\n    } else {\n        for (var i = 0; i < geometry.length; i++) {\n            calcRingBBox(min, max, geometry[i]);\n        }\n    }\n\n    return feature;\n}\n\nfunction calcRingBBox(min, max, points) {\n    for (var i = 0, p; i < points.length; i++) {\n        p = points[i];\n        min[0] = Math.min(p[0], min[0]);\n        max[0] = Math.max(p[0], max[0]);\n        min[1] = Math.min(p[1], min[1]);\n        max[1] = Math.max(p[1], max[1]);\n    }\n}\n\nvar convert_1 = convert$1;\n\nvar simplify = simplify_1;\nvar createFeature = feature;\n\n// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\n\nfunction convert$1(data, tolerance) {\n    var features = [];\n\n    if (data.type === 'FeatureCollection') {\n        for (var i = 0; i < data.features.length; i++) {\n            convertFeature(features, data.features[i], tolerance);\n        }\n    } else if (data.type === 'Feature') {\n        convertFeature(features, data, tolerance);\n\n    } else {\n        // single geometry or a geometry collection\n        convertFeature(features, {geometry: data}, tolerance);\n    }\n    return features;\n}\n\nfunction convertFeature(features, feature$$1, tolerance) {\n    if (feature$$1.geometry === null) {\n        // ignore features with null geometry\n        return;\n    }\n\n    var geom = feature$$1.geometry,\n        type = geom.type,\n        coords = geom.coordinates,\n        tags = feature$$1.properties,\n        id = feature$$1.id,\n        i, j, rings, projectedRing;\n\n    if (type === 'Point') {\n        features.push(createFeature(tags, 1, [projectPoint(coords)], id));\n\n    } else if (type === 'MultiPoint') {\n        features.push(createFeature(tags, 1, project(coords), id));\n\n    } else if (type === 'LineString') {\n        features.push(createFeature(tags, 2, [project(coords, tolerance)], id));\n\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n        rings = [];\n        for (i = 0; i < coords.length; i++) {\n            projectedRing = project(coords[i], tolerance);\n            if (type === 'Polygon') { projectedRing.outer = (i === 0); }\n            rings.push(projectedRing);\n        }\n        features.push(createFeature(tags, type === 'Polygon' ? 3 : 2, rings, id));\n\n    } else if (type === 'MultiPolygon') {\n        rings = [];\n        for (i = 0; i < coords.length; i++) {\n            for (j = 0; j < coords[i].length; j++) {\n                projectedRing = project(coords[i][j], tolerance);\n                projectedRing.outer = (j === 0);\n                rings.push(projectedRing);\n            }\n        }\n        features.push(createFeature(tags, 3, rings, id));\n\n    } else if (type === 'GeometryCollection') {\n        for (i = 0; i < geom.geometries.length; i++) {\n            convertFeature(features, {\n                geometry: geom.geometries[i],\n                properties: tags\n            }, tolerance);\n        }\n\n    } else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n}\n\nfunction project(lonlats, tolerance) {\n    var projected = [];\n    for (var i = 0; i < lonlats.length; i++) {\n        projected.push(projectPoint(lonlats[i]));\n    }\n    if (tolerance) {\n        simplify(projected, tolerance);\n        calcSize(projected);\n    }\n    return projected;\n}\n\nfunction projectPoint(p) {\n    var sin = Math.sin(p[1] * Math.PI / 180),\n        x = (p[0] / 360 + 0.5),\n        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n    y = y < 0 ? 0 :\n        y > 1 ? 1 : y;\n\n    return [x, y, 0];\n}\n\n// calculate area and length of the poly\nfunction calcSize(points) {\n    var area = 0,\n        dist = 0;\n\n    for (var i = 0, a, b; i < points.length - 1; i++) {\n        a = b || points[i];\n        b = points[i + 1];\n\n        area += a[0] * b[1] - b[0] * a[1];\n\n        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation\n        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);\n    }\n    points.area = Math.abs(area / 2);\n    points.dist = dist;\n}\n\nvar tile = transformTile;\nvar point = transformPoint;\n\n// Transforms the coordinates of each feature in the given tile from\n// mercator-projected space into (extent x extent) tile space.\nfunction transformTile(tile, extent) {\n    if (tile.transformed) { return tile; }\n\n    var z2 = tile.z2,\n        tx = tile.x,\n        ty = tile.y,\n        i, j, k;\n\n    for (i = 0; i < tile.features.length; i++) {\n        var feature = tile.features[i],\n            geom = feature.geometry,\n            type = feature.type;\n\n        if (type === 1) {\n            for (j = 0; j < geom.length; j++) { geom[j] = transformPoint(geom[j], extent, z2, tx, ty); }\n\n        } else {\n            for (j = 0; j < geom.length; j++) {\n                var ring = geom[j];\n                for (k = 0; k < ring.length; k++) { ring[k] = transformPoint(ring[k], extent, z2, tx, ty); }\n            }\n        }\n    }\n\n    tile.transformed = true;\n\n    return tile;\n}\n\nfunction transformPoint(p, extent, z2, tx, ty) {\n    var x = Math.round(extent * (p[0] * z2 - tx)),\n        y = Math.round(extent * (p[1] * z2 - ty));\n    return [x, y];\n}\n\nvar transform$1 = {\n\ttile: tile,\n\tpoint: point\n};\n\nvar clip_1 = clip$1;\n\nvar createFeature$2 = feature;\n\n/* clip features between two axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   ____|____/\n *     |        |\n */\n\nfunction clip$1(features, scale, k1, k2, axis, intersect, minAll, maxAll) {\n\n    k1 /= scale;\n    k2 /= scale;\n\n    if (minAll >= k1 && maxAll <= k2) { return features; } // trivial accept\n    else if (minAll > k2 || maxAll < k1) { return null; } // trivial reject\n\n    var clipped = [];\n\n    for (var i = 0; i < features.length; i++) {\n\n        var feature$$1 = features[i],\n            geometry = feature$$1.geometry,\n            type = feature$$1.type,\n            min, max;\n\n        min = feature$$1.min[axis];\n        max = feature$$1.max[axis];\n\n        if (min >= k1 && max <= k2) { // trivial accept\n            clipped.push(feature$$1);\n            continue;\n        } else if (min > k2 || max < k1) { continue; } // trivial reject\n\n        var slices = type === 1 ?\n                clipPoints(geometry, k1, k2, axis) :\n                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);\n\n        if (slices.length) {\n            // if a feature got clipped, it will likely get clipped on the next zoom level as well,\n            // so there's no need to recalculate bboxes\n            clipped.push(createFeature$2(feature$$1.tags, type, slices, feature$$1.id));\n        }\n    }\n\n    return clipped.length ? clipped : null;\n}\n\nfunction clipPoints(geometry, k1, k2, axis) {\n    var slice = [];\n\n    for (var i = 0; i < geometry.length; i++) {\n        var a = geometry[i],\n            ak = a[axis];\n\n        if (ak >= k1 && ak <= k2) { slice.push(a); }\n    }\n    return slice;\n}\n\nfunction clipGeometry(geometry, k1, k2, axis, intersect, closed) {\n\n    var slices = [];\n\n    for (var i = 0; i < geometry.length; i++) {\n\n        var ak = 0,\n            bk = 0,\n            b = null,\n            points = geometry[i],\n            area = points.area,\n            dist = points.dist,\n            outer = points.outer,\n            len = points.length,\n            a, j, last;\n\n        var slice = [];\n\n        for (j = 0; j < len - 1; j++) {\n            a = b || points[j];\n            b = points[j + 1];\n            ak = bk || a[axis];\n            bk = b[axis];\n\n            if (ak < k1) {\n\n                if ((bk > k2)) { // ---|-----|--\x3e\n                    slice.push(intersect(a, b, k1), intersect(a, b, k2));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk >= k1) { slice.push(intersect(a, b, k1)); } // ---|--\x3e  |\n\n            } else if (ak > k2) {\n\n                if ((bk < k1)) { // <--|-----|---\n                    slice.push(intersect(a, b, k2), intersect(a, b, k1));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk <= k2) { slice.push(intersect(a, b, k2)); } // |  <--|---\n\n            } else {\n\n                slice.push(a);\n\n                if (bk < k1) { // <--|---  |\n                    slice.push(intersect(a, b, k1));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk > k2) { // |  ---|--\x3e\n                    slice.push(intersect(a, b, k2));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n                }\n                // | --\x3e |\n            }\n        }\n\n        // add the last point\n        a = points[len - 1];\n        ak = a[axis];\n        if (ak >= k1 && ak <= k2) { slice.push(a); }\n\n        // close the polygon if its endpoints are not the same after clipping\n\n        last = slice[slice.length - 1];\n        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) { slice.push(slice[0]); }\n\n        // add the final slice\n        newSlice(slices, slice, area, dist, outer);\n    }\n\n    return slices;\n}\n\nfunction newSlice(slices, slice, area, dist, outer) {\n    if (slice.length) {\n        // we don't recalculate the area/length of the unclipped geometry because the case where it goes\n        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work\n        slice.area = area;\n        slice.dist = dist;\n        if (outer !== undefined) { slice.outer = outer; }\n\n        slices.push(slice);\n    }\n    return [];\n}\n\nvar clip$2 = clip_1;\nvar createFeature$3 = feature;\n\nvar wrap_1 = wrap$1;\n\nfunction wrap$1(features, buffer, intersectX) {\n    var merged = features,\n        left  = clip$2(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy\n        right = clip$2(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy\n\n    if (left || right) {\n        merged = clip$2(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2) || []; // center world copy\n\n        if (left) { merged = shiftFeatureCoords(left, 1).concat(merged); } // merge left into center\n        if (right) { merged = merged.concat(shiftFeatureCoords(right, -1)); } // merge right into center\n    }\n\n    return merged;\n}\n\nfunction shiftFeatureCoords(features, offset) {\n    var newFeatures = [];\n\n    for (var i = 0; i < features.length; i++) {\n        var feature$$1 = features[i],\n            type = feature$$1.type;\n\n        var newGeometry;\n\n        if (type === 1) {\n            newGeometry = shiftCoords(feature$$1.geometry, offset);\n        } else {\n            newGeometry = [];\n            for (var j = 0; j < feature$$1.geometry.length; j++) {\n                newGeometry.push(shiftCoords(feature$$1.geometry[j], offset));\n            }\n        }\n\n        newFeatures.push(createFeature$3(feature$$1.tags, type, newGeometry, feature$$1.id));\n    }\n\n    return newFeatures;\n}\n\nfunction shiftCoords(points, offset) {\n    var newPoints = [];\n    newPoints.area = points.area;\n    newPoints.dist = points.dist;\n\n    for (var i = 0; i < points.length; i++) {\n        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);\n    }\n    return newPoints;\n}\n\nvar tile$1 = createTile$1;\n\nfunction createTile$1(features, z2, tx, ty, tolerance, noSimplify) {\n    var tile = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: tx,\n        y: ty,\n        z2: z2,\n        transformed: false,\n        min: [2, 1],\n        max: [-1, 0]\n    };\n    for (var i = 0; i < features.length; i++) {\n        tile.numFeatures++;\n        addFeature(tile, features[i], tolerance, noSimplify);\n\n        var min = features[i].min,\n            max = features[i].max;\n\n        if (min[0] < tile.min[0]) { tile.min[0] = min[0]; }\n        if (min[1] < tile.min[1]) { tile.min[1] = min[1]; }\n        if (max[0] > tile.max[0]) { tile.max[0] = max[0]; }\n        if (max[1] > tile.max[1]) { tile.max[1] = max[1]; }\n    }\n    return tile;\n}\n\nfunction addFeature(tile, feature, tolerance, noSimplify) {\n\n    var geom = feature.geometry,\n        type = feature.type,\n        simplified = [],\n        sqTolerance = tolerance * tolerance,\n        i, j, ring, p;\n\n    if (type === 1) {\n        for (i = 0; i < geom.length; i++) {\n            simplified.push(geom[i]);\n            tile.numPoints++;\n            tile.numSimplified++;\n        }\n\n    } else {\n\n        // simplify and transform projected coordinates for tile geometry\n        for (i = 0; i < geom.length; i++) {\n            ring = geom[i];\n\n            // filter out tiny polylines & polygons\n            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||\n                                (type === 3 && ring.area < sqTolerance))) {\n                tile.numPoints += ring.length;\n                continue;\n            }\n\n            var simplifiedRing = [];\n\n            for (j = 0; j < ring.length; j++) {\n                p = ring[j];\n                // keep points with importance > tolerance\n                if (noSimplify || p[2] > sqTolerance) {\n                    simplifiedRing.push(p);\n                    tile.numSimplified++;\n                }\n                tile.numPoints++;\n            }\n\n            if (type === 3) { rewind(simplifiedRing, ring.outer); }\n\n            simplified.push(simplifiedRing);\n        }\n    }\n\n    if (simplified.length) {\n        var tileFeature = {\n            geometry: simplified,\n            type: type,\n            tags: feature.tags || null\n        };\n        if (feature.id !== null) {\n            tileFeature.id = feature.id;\n        }\n        tile.features.push(tileFeature);\n    }\n}\n\nfunction rewind(ring, clockwise) {\n    var area = signedArea(ring);\n    if (area < 0 === clockwise) { ring.reverse(); }\n}\n\nfunction signedArea(ring) {\n    var sum = 0;\n    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n    }\n    return sum;\n}\n\nvar index = geojsonvt;\n\nvar convert = convert_1;\nvar transform = transform$1;\nvar clip = clip_1;\nvar wrap = wrap_1;\nvar createTile = tile$1;     // final simplified tile generation\n\n\nfunction geojsonvt(data, options) {\n    return new GeoJSONVT(data, options);\n}\n\nfunction GeoJSONVT(data, options) {\n    options = this.options = extend(Object.create(this.options), options);\n\n    var debug = options.debug;\n\n    if (debug) { console.time('preprocess data'); }\n\n    var z2 = 1 << options.maxZoom, // 2^z\n        features = convert(data, options.tolerance / (z2 * options.extent));\n\n    this.tiles = {};\n    this.tileCoords = [];\n\n    if (debug) {\n        console.timeEnd('preprocess data');\n        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n        console.time('generate tiles');\n        this.stats = {};\n        this.total = 0;\n    }\n\n    features = wrap(features, options.buffer / options.extent, intersectX);\n\n    // start slicing from the top tile down\n    if (features.length) { this.splitTile(features, 0, 0, 0); }\n\n    if (debug) {\n        if (features.length) { console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints); }\n        console.timeEnd('generate tiles');\n        console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n    }\n}\n\nGeoJSONVT.prototype.options = {\n    maxZoom: 14,            // max zoom to preserve detail on\n    indexMaxZoom: 5,        // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    solidChildren: false,   // whether to tile solid square tiles further\n    tolerance: 3,           // simplification tolerance (higher means simpler)\n    extent: 4096,           // tile extent\n    buffer: 64,             // tile buffer on each side\n    debug: 0                // logging level (0, 1 or 2)\n};\n\nGeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {\n    var this$1 = this;\n\n\n    var stack = [features, z, x, y],\n        options = this.options,\n        debug = options.debug,\n        solid = null;\n\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n        y = stack.pop();\n        x = stack.pop();\n        z = stack.pop();\n        features = stack.pop();\n\n        var z2 = 1 << z,\n            id = toID(z, x, y),\n            tile = this$1.tiles[id],\n            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);\n\n        if (!tile) {\n            if (debug > 1) { console.time('creation'); }\n\n            tile = this$1.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);\n            this$1.tileCoords.push({z: z, x: x, y: y});\n\n            if (debug) {\n                if (debug > 1) {\n                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                    console.timeEnd('creation');\n                }\n                var key = 'z' + z;\n                this$1.stats[key] = (this$1.stats[key] || 0) + 1;\n                this$1.total++;\n            }\n        }\n\n        // save reference to original geometry in tile so that we can drill down later if we stop now\n        tile.source = features;\n\n        // if it's the first-pass tiling\n        if (!cz) {\n            // stop tiling if we reached max zoom, or if the tile is too simple\n            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) { continue; }\n\n        // if a drilldown to a specific tile\n        } else {\n            // stop tiling if we reached base zoom or our target tile zoom\n            if (z === options.maxZoom || z === cz) { continue; }\n\n            // stop tiling if it's not an ancestor of the target tile\n            var m = 1 << (cz - z);\n            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) { continue; }\n        }\n\n        // stop tiling if the tile is solid clipped square\n        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {\n            if (cz) { solid = z; } // and remember the zoom if we're drilling down\n            continue;\n        }\n\n        // if we slice further down, no need to keep source geometry\n        tile.source = null;\n\n        if (debug > 1) { console.time('clipping'); }\n\n        // values we'll use for clipping\n        var k1 = 0.5 * options.buffer / options.extent,\n            k2 = 0.5 - k1,\n            k3 = 0.5 + k1,\n            k4 = 1 + k1,\n            tl, bl, tr, br, left, right;\n\n        tl = bl = tr = br = null;\n\n        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);\n        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);\n\n        if (left) {\n            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);\n            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);\n        }\n\n        if (right) {\n            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);\n            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);\n        }\n\n        if (debug > 1) { console.timeEnd('clipping'); }\n\n        if (features.length) {\n            stack.push(tl || [], z + 1, x * 2,     y * 2);\n            stack.push(bl || [], z + 1, x * 2,     y * 2 + 1);\n            stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n            stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n        }\n    }\n\n    return solid;\n};\n\nGeoJSONVT.prototype.getTile = function (z, x, y) {\n    var this$1 = this;\n\n    var options = this.options,\n        extent = options.extent,\n        debug = options.debug;\n\n    var z2 = 1 << z;\n    x = ((x % z2) + z2) % z2; // wrap tile x coordinate\n\n    var id = toID(z, x, y);\n    if (this.tiles[id]) { return transform.tile(this.tiles[id], extent); }\n\n    if (debug > 1) { console.log('drilling down to z%d-%d-%d', z, x, y); }\n\n    var z0 = z,\n        x0 = x,\n        y0 = y,\n        parent;\n\n    while (!parent && z0 > 0) {\n        z0--;\n        x0 = Math.floor(x0 / 2);\n        y0 = Math.floor(y0 / 2);\n        parent = this$1.tiles[toID(z0, x0, y0)];\n    }\n\n    if (!parent || !parent.source) { return null; }\n\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    if (debug > 1) { console.log('found parent tile z%d-%d-%d', z0, x0, y0); }\n\n    // it parent tile is a solid clipped square, return it instead since it's identical\n    if (isClippedSquare(parent, extent, options.buffer)) { return transform.tile(parent, extent); }\n\n    if (debug > 1) { console.time('drilling down'); }\n    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);\n    if (debug > 1) { console.timeEnd('drilling down'); }\n\n    // one of the parent tiles was a solid clipped square\n    if (solid !== null) {\n        var m = 1 << (z - solid);\n        id = toID(solid, Math.floor(x / m), Math.floor(y / m));\n    }\n\n    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;\n};\n\nfunction toID(z, x, y) {\n    return (((1 << z) * y + x) * 32) + z;\n}\n\nfunction intersectX(a, b, x) {\n    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];\n}\nfunction intersectY(a, b, y) {\n    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];\n}\n\nfunction extend(dest, src) {\n    for (var i in src) { dest[i] = src[i]; }\n    return dest;\n}\n\n// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further\nfunction isClippedSquare(tile, extent, buffer) {\n\n    var features = tile.source;\n    if (features.length !== 1) { return false; }\n\n    var feature = features[0];\n    if (feature.type !== 3 || feature.geometry.length > 1) { return false; }\n\n    var len = feature.geometry[0].length;\n    if (len !== 5) { return false; }\n\n    for (var i = 0; i < len; i++) {\n        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);\n        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||\n            (p[1] !== -buffer && p[1] !== extent + buffer)) { return false; }\n    }\n\n    return true;\n}\n\nvar identity = function(x) {\n  return x;\n};\n\nvar transform$3 = function(topology) {\n  if ((transform = topology.transform) == null) { return identity; }\n  var transform,\n      x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(point, i) {\n    if (!i) { x0 = y0 = 0; }\n    point[0] = (x0 += point[0]) * kx + dx;\n    point[1] = (y0 += point[1]) * ky + dy;\n    return point;\n  };\n};\n\nvar bbox = function(topology) {\n  var bbox = topology.bbox;\n\n  function bboxPoint(p0) {\n    p1[0] = p0[0], p1[1] = p0[1], t(p1);\n    if (p1[0] < x0) { x0 = p1[0]; }\n    if (p1[0] > x1) { x1 = p1[0]; }\n    if (p1[1] < y0) { y0 = p1[1]; }\n    if (p1[1] > y1) { y1 = p1[1]; }\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  if (!bbox) {\n    var t = transform$3(topology), p0, p1 = new Array(2), name,\n        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n    topology.arcs.forEach(function(arc) {\n      var i = -1, n = arc.length;\n      while (++i < n) {\n        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);\n        if (p1[0] < x0) { x0 = p1[0]; }\n        if (p1[0] > x1) { x1 = p1[0]; }\n        if (p1[1] < y0) { y0 = p1[1]; }\n        if (p1[1] > y1) { y1 = p1[1]; }\n      }\n    });\n\n    for (name in topology.objects) {\n      bboxGeometry(topology.objects[name]);\n    }\n\n    bbox = topology.bbox = [x0, y0, x1, y1];\n  }\n\n  return bbox;\n};\n\nvar reverse = function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) { t = array[i], array[i++] = array[j], array[j] = t; }\n};\n\nvar feature$2 = function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$3(topology, o); })}\n      : feature$3(topology, o);\n};\n\nfunction feature$3(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform$3(topology),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) { points.pop(); }\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k].slice(), k));\n    }\n    if (i < 0) { reverse(points, n); }\n  }\n\n  function point(p) {\n    return transformPoint(p.slice());\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) { arc(arcs[i], points); }\n    if (points.length < 2) { points.push(points[0].slice()); }\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) { points.push(points[0].slice()); }\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nvar stitch = function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) { p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; }); }\n    else { p1 = arc[arc.length - 1]; }\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) { fragments.push([i]); } });\n\n  return fragments;\n};\n\nfunction extractArcs(topology, object$$1, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object$$1);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) { arcs.push(geoms[0].i); } });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) { a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0]; }\n  return Math.abs(area); // Note: doubled area!\n}\n\nvar bisect = function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nvar slicers = {};\nvar options;\n\nonmessage = function (e) {\n\tif (e.data[0] === 'slice') {\n\t\t// Given a blob of GeoJSON and some topojson/geojson-vt options, do the slicing.\n\t\tvar geojson = e.data[1];\n\t\toptions     = e.data[2];\n\n\t\tif (geojson.type && geojson.type === 'Topology') {\n\t\t\tfor (var layerName in geojson.objects) {\n\t\t\t\tslicers[layerName] = index(\n\t\t\t\t\tfeature$2(geojson, geojson.objects[layerName])\n\t\t\t\t, options);\n\t\t\t}\n\t\t} else {\n\t\t\tslicers[options.vectorTileLayerName] = index(geojson, options);\n\t\t}\n\n\t} else if (e.data[0] === 'get') {\n\t\t// Gets the vector tile for the given coordinates, sends it back as a message\n\t\tvar coords = e.data[1];\n\n\t\tvar tileLayers = {};\n\t\tfor (var layerName in slicers) {\n\t\t\tvar slicedTileLayer = slicers[layerName].getTile(coords.z, coords.x, coords.y);\n\n\t\t\tif (slicedTileLayer) {\n\t\t\t\tvar vectorTileLayer = {\n\t\t\t\t\tfeatures: [],\n\t\t\t\t\textent: options.extent,\n\t\t\t\t\tname: options.vectorTileLayerName,\n\t\t\t\t\tlength: slicedTileLayer.features.length\n\t\t\t\t};\n\n\t\t\t\tfor (var i in slicedTileLayer.features) {\n\t\t\t\t\tvar feat = {\n\t\t\t\t\t\tgeometry: slicedTileLayer.features[i].geometry,\n\t\t\t\t\t\tproperties: slicedTileLayer.features[i].tags,\n\t\t\t\t\t\ttype: slicedTileLayer.features[i].type\t// 1 = point, 2 = line, 3 = polygon\n\t\t\t\t\t};\n\t\t\t\t\tvectorTileLayer.features.push(feat);\n\t\t\t\t}\n\t\t\t\ttileLayers[layerName] = vectorTileLayer;\n\t\t\t}\n\t\t}\n\t\tpostMessage({ layers: tileLayers, coords: coords });\n\t}\n};\n//# sourceMappingURL=slicerWebWorker.js.worker.map\n","text/plain; charset=us-ascii",!1);L.VectorGrid.Slicer=L.VectorGrid.extend({options:{vectorTileLayerName:"sliced",extent:4096,maxZoom:14},initialize:function(a,b){L.VectorGrid.prototype.initialize.call(this,b);var b={};for(var c in this.options)"rendererFactory"!==c&&"vectorTileLayerStyles"!==c&&"function"!=typeof this.options[c]&&(b[c]=this.options[c]);this._worker=new Worker(ba),this._worker.postMessage(["slice",a,b])},_getVectorTilePromise:function(a){var b=this,c=new Promise(function(d){b._worker.addEventListener("message",function c(e){e.data.coords&&e.data.coords.x===a.x&&e.data.coords.y===a.y&&e.data.coords.z===a.z&&(d(e.data),b._worker.removeEventListener("message",c))})});return this._worker.postMessage(["get",a]),c}}),L.vectorGrid.slicer=function(a,b){return new L.VectorGrid.Slicer(a,b)},L.Canvas.Tile=L.Canvas.extend({initialize:function(a,b,c){L.Canvas.prototype.initialize.call(this,c),this._tileCoord=a,this._size=b,this._initContainer(),this._container.setAttribute("width",this._size.x),this._container.setAttribute("height",this._size.y),this._layers={},this._drawnLayers={},this._drawing=!0,c.interactive&&(this._container.style.pointerEvents="auto")},getCoord:function(){return this._tileCoord},getContainer:function(){return this._container},getOffset:function(){return this._tileCoord.scaleBy(this._size).subtract(this._map.getPixelOrigin())},onAdd:L.Util.falseFn,addTo:function(a){this._map=a},_onClick:function(a){var d,b=this._map.mouseEventToLayerPoint(a).subtract(this.getOffset()),c=[];for(var e in this._layers)d=this._layers[e],d.options.interactive&&d._containsPoint(b)&&!this._map._draggableMoved(d)&&(L.DomEvent._fakeStop(a),c.push(d));c.length&&this._fireEvent(c,a)},_onMouseMove:function(a){if(this._map&&!this._map.dragging.moving()&&!this._map._animatingZoom){var b=this._map.mouseEventToLayerPoint(a).subtract(this.getOffset());this._handleMouseOut(a,b),this._handleMouseHover(a,b)}}}),L.canvas.tile=function(a,b,c){return new L.Canvas.Tile(a,b,c)}}();
